# Quick dive into Java

### База

На этапе разработки мы используем то, что называется `Embedded Database` --  вместо полноценной базы данных у нас каждый раз при запуске создается база данных, хранящая данные в файле или в оперативной памяти. Это позволяет не заморачиваться с конфигурацией базы на этапе разработки. При этом интерфейс доступа к базе от перехода к `PostgreSQL` никак не поменяется. Если любопытно, сейчас для этих целей мы используем HSQLDB.
Для работы с базой у нас преимущественно используются три класса:

1. `DataSource`: Объект класса содержит в себе описание подключения к базе: адрес базы в сети, логин и пароль, тип базы данных. Сейчас у нас используется локальная база данных, автоматически разворачивающаяся при запуске. Чтобы перейти с `HSQL` на `Postgre` нужно будет изменить только то, как создается этот объект. Используется в классе `DatabaseConfig`. При создании `HSQL` базы на нее применяются SQL-скрипты, описанные в файле `schema.sql`.

2. `JdbcTemplate`: Объект класса предоставляет доступ к выполнению запросов в базе. Определяется в `DatabaseConfig`, используется во всех классах, где есть потребность в обращении в базу. `JdbcTemplate::query` множество методов для запросов, возвращающих результат. `JdbcTemplate::update` для запросов, соответствующих добавлению, удалению, изменению.

3. `RowMapper`: У каждого класса, которому соответствует сущность в базе данных, создается вложенный класс-RowMapper. Он нужен для использования в `JdbcTemplate`. Этот класс определяет то, как по строке из базы строится объект. Нами используется для лаконичности в запросах `JdbcTemplate::queryForObject`, `JdbcTemplate::queryForList`.


### Обработка запросов

Метод `WarshipBot::onUpdateReceived` вызывается каждый раз при получении ботом сообщения. В этом методе по очереди вызываются методы `handle` различных `Handler’ов`. Каждый `Handler` может быть ответственным за такой тип сообщения или не быть. Если Handler ответственен за сообщение, он возвращает сообщение, которое должно быть отправлено пользователю в качестве ответа. Если нет, то `Handler::handle` должен вернуть null. При этом определение того, ответственен обработчик за сообщение или нет, является обязанностью самого обработчика. При этом есть желание, чтобы список команд у разных обработчиков не пересекался. Это позволит нам не бояться все сломать переупорядочиванием обработчиков.

### Механика


#### Перемещение

Итак, механика. Каждый порт пренадлежит ровно одной фракции. Игрок, находясь в порту своей фракции, имеет две(три?(четыре?)) возможности:
1. Отправиться вместе с торговым караваном в другой порт своей фракции:
	* Он может перевозить груз. Давайте не выделять конкретные типы грузов, просто чел плывет и получает за это деньги пропорционально расстоянию(времени в пути).
	* Он может сопровождать перевозящего груз. Тогда он получает деньги по какому-то тарифу от того, кто его нанамает. При этом, чтобы упростить механику, торговец назначает цену за одну единицу боевой мощности и условия отправления. Условия отправления это время, которое он ждет перед отправкой + количество боевых единиц, которые набрались в его сопровождении. Как только эти условия выполняются, торговец с эскортом отправляются.


2. Отправиться в нападение на порт врага:
	* Он  может объявить атаку аналогично перевозке груза. Тоже с условиями по времени ожидания и по количеству боевых единиц.
	* Он может присоединиться к уже назначенной атаке. Деньги получают, грабя порт и разделяя пропорционально силе богатства порта. При этом фракция, на которую нападают, получает некоторым образом оповещение о том, что на ее порт выдвинулись враги? Или просто беззащитно ожидать?

3. Он может отправиться перехватывать корабли, следующие по какому-либо маршруту. Тут механика аналогична предыдущим двум пунктам: собирается команда, которая патрулирует в течение определенного времени определенный торговый путь. Соответственно, если перехватчики оказываются сильнее, чем эксорт торговца, то торговца грабят. Тогда условно говоря торговец теряет 10% имущества, а каждый корабль эскорта — по 5%. Грабители возвращаются в порт. Перемещение до торгового пути и обратно до порта занимают время. Возможно, грабителю нужно предоставить какие-то частичные данные о кораблях, которые он заметил — типы кораблей, но не количество пушек, чтобы у грабителя был риск, чтобы он мог напороться на сильное сопротивление и прососать.

4. Перемещаться между портами, не перевозя груз и ни на кого не нападая:
	* Чтобы торговать по другому маршруту
	* Чтобы собраться в одном месте с товарищами для атаки
	* Чтобы встать на защиту своего порта


#### Порты

* Портов пока что пять, в рабочем условно сорок, определим экспериментально.
* Порты располагаются в прямоугольнике условно 20x80. 
* Торговать можно между любыми двумя, нападать только на тот, который находится недалеко. 
* Для каждого порта хранятся его координаты в прямоугольнике и расстояние до всех остальных портов. 
* Координаты нужны для того, чтобы рисовать пользователю карту архипелага. 
* Можно написать скрипт на питоне, который будет по коориднатам нового острова генерировать расстояния до всех остальных островов. В перспективе использовать админский интерфейс бота для создания новых островов и других изменений в базе.
